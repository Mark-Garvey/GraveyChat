//=================================================
// DO NOT EDIT THIS FILE
//
// This file is part of the standard chat service
// for NV:MP. You may be encouraged to edit this
// file, but for your safety please DO NOT change
// the contents.
// 
// If you would like to change the style of the
// chat, create your own .css files and add them
// to the chat.html document using the proper 
// <link> tags.
//=================================================

function ChatManager()
{
    const kViewableMessageLimit = 50;        // How many messages should be visible by the player at a time.
    const kDefaultColour = [255, 255, 255];  // The default colour to resort to invalid colour formats.
    const kDimTimeRemote = 10000;            // Time before the panel dims from a remote message.
    const kDimTimeLocal = 2000;              // Time before the panel dims from coming out of the input box.

    const kMaxMessageHistory = 80;			// Player sent Command/Chat history.
	
	//used for currentChannel
	const channelType = {
		ALL: 'all',
		GLOBAL: 'global',
		LOCAL: 'local',
		FACTION: 'factions',
		WHISPER: 'whisper',
		SYSTEM: 'system',
	}
	var currentChannel = channelType.ALL;
	
	//chck if settings menu is open
	var isSettingsOpen = false;
	
	//Array queues that hold messages for a specified channel(all/global/local/faction/whisper/system)
	//Each array holds up to kViewableMessageLimit amount
	//delimter used is § (alt 21)
	var allChat = [];
	var globalChat = [];
	var localChat = [];
	var factionChat = []
	var whisperChat = [];
	var systemChat = [];
	
	this.storeMessage = function(channel, name, text, colour) {
		if(allChat.length >= kViewableMessageLimit)
			allChat.shift();
		
		switch(channel) {
			case "system": 
			{
				if(systemChat.length >= kViewableMessageLimit) 
					systemChat.shift();
				
				allChat.push(channel + "§" + text + "§" + colour);
				systemChat.push(channel + "§" + text + "§" + colour);
				break;
			}
			
			case "global":
			{
				if(globalChat.length >= kViewableMessageLimit) 
					globalChat.shift();
				
				allChat.push(channel + "§" + name + "§" + text + "§" + colour);
				globalChat.push(channel + "§"  + name + "§" + text + "§" + colour);
				break;
			}
			
			case "local":
			{
				if(localChat.length >= kViewableMessageLimit) 
					localChat.shift();
				
				
				allChat.push(channel + "§" + name + "§" + text + "§" + colour);
				localChat.push(channel + "§"  + name + "§" + text + "§" + colour);
				break;
			}
			
			case "factions":
			{
				if(factionChat.length >= kViewableMessageLimit) 
					factionChat.shift();
				
				allChat.push(channel + "§" + name + "§" + text + "§" + colour);
				factionChat.push(channel + "§"  + name + "§" + text + "§" + colour);
				break;
			}		
			
			case "whisper":
			{
				if(whisperChat.length >= kViewableMessageLimit)
					whisperChat.shift();
				
				//colour is a boolean (for is_local) when a whisper message is passed in
				(colour) ? colour = 1 : colour = 0;
				allChat.push(channel + "§" + name + "§" + text + "§" + colour);
				whisperChat.push(channel + "§"  + name + "§" + text + "§" + colour);
				break;
			}
		};
		
	};
	
    const kKeyboardInput =
    {
        escape 	: 27,
        enter  	: 13,
        up     	: 38,
        down   	: 40,
        pageup  : 33,
        pagedown: 34,
		f4		: 115,
		f5		: 116,
		f6		: 117,
		f7		: 118,
		f8		: 119,
		f9		: 120,
		f10		: 121
    };

    var message_history = [];
    var history_index = 0;
    var gamemode = null;

    // DOM element cache.
    var input_box, messages, content;
	input_box = messages = content = null;

    // Temporary storage.
    var temp_placeholder = null;

    // Timers
    var dim_timer = null,
        gm_timer = null;

  
    this.record_message = function (message) {
        if (message_history.length >= kMaxMessageHistory) {
            message_history.pop();
        }

        // Reset index back to start of list.
        history_index = 0;
        message_history.unshift(message)
    };

    this.get_last_message = function (index) {
        if (index >= message_history.length) {
            return null;
        }

        return message_history[index];
    };

    this.check_for_gm = function () {
        var faction_status = app.sio_get("NetServerConfig", "sv_enablefactions");
        if (faction_status !== null && faction_status == 1)
        {
            gamemode = new Factions(this);
            clearInterval(gm_timer);
        }
    };

    // Focuses the chat box.
    this.focus = function () {
        $(input_box).focus();
        this.on_input_box_focus();
    };

    this.dim_then_time = function () {
        this.do_dim();
        this.start_undim(kDimTimeRemote);
    };

    this.start_undim = function (t) {
        t = t || kDimTimeLocal;
        this.stop_undim();
        this.dim_timer = setTimeout(this.do_undim.bind(this), t);
    };

    this.stop_undim = function () {
        if (this.dim_timer != null) {
            clearTimeout(this.dim_timer);
            this.dim_timer = null;
        }
    };

    this.do_dim = function () {
        this.stop_undim();
        messages.attr("class", "dim");
        messages.css("overflow-y", "scroll");
    };

    this.do_undim = function () {
        messages.attr("class", "clear");
        messages.css("overflow-y", "hidden");
    };

    this.on_input_box_focus = function () {
        // Go to the bottom of the chat.
        this.reorder();

        // Store the original placeholder and replace it with an empty
        // body to signal that it's waiting for input.
        this.temp_placeholder = input_box.getAttribute("placeholder");

        input_box.setAttribute("placeholder", "");
        input_box.setAttribute("class", "focused");
        this.do_dim();
    };

    this.on_input_box_unfocus = function () {

        // Restore the old placeholder if it was previously saved.
        if (temp_placeholder !== null) {
            input_box.setAttribute("placeholder", temp_placeholder);
            temp_placeholder = null;
        }

        // Clear the text.
        input_box.value = "";
        this.start_undim();
        input_box.setAttribute("class", "");

        window.app.on_losefocus();
    };

    this.blur = function () {

        if (input_box.value.length === 0) {
            $(input_box).blur();
        }

    };

    this.send = function () {
        var text = input_box.value.trim();

        if (text == "") {
            return;
        }

        this.record_message(text);

        switch (text)
        {
            case "/suicide":
            case "/die":
            case "/respawn":
                window.app.fire_suicide();
                return;

            case "/quit":
            case "/q":
                window.app.fire_quit();
                return;
        }

        window.app.on_message(input_box.value); 

        input_box.value = "";
        $(input_box).blur();
    };

    this.on_input_box_keypress = function (evt) {
        switch (evt.keyCode)
        {
            //case kKeyboardInput.escape:
            //{
            //    $(input_box).trigger('blur');
            //    break;
            //}
            case kKeyboardInput.enter:
            {
                this.send();
                break;
            }
            case kKeyboardInput.up:
            {
                var msg = this.get_last_message(history_index);
                if (msg) {
                    $(input_box).val(msg);
                    history_index++;
                }
                break;
            }
            case kKeyboardInput.down:
            {
                if (history_index <= 0) {
                    $(input_box).val("");
                    return;
                }
                history_index--;

                var msg = this.get_last_message(history_index);
                if (msg) {
                    $(input_box).val(msg);
                }
                break;
            }
            case kKeyboardInput.pagedown:
            {
                messages.get(0).scrollTop += 100;
                break;
            }
            case kKeyboardInput.pageup:
            {
                messages.get(0).scrollTop -= Math.min(100, messages.get(0).scrollTop);
                break;
            }
			
			case kKeyboardInput.f4:
            {
                if(isSettingsOpen) {
					closeSettings()
					isSettingsOpen = false;
				} 
				else {
					openSettings();
					isSettingsOpen = true;
				}
                break;
            }
			
			case kKeyboardInput.f5:
			{
				//display all chat
				currentChannel = channelType.ALL;
				this.clearChatBox();
				for(var i = 0; i < allChat.length; i++) {
					var message = allChat[i] + '';
					message = message.split("§");
					if(message[0] == "system") {
						this.addSystemMessageFormatted(message[1], message[2]);  
					}
					else if(message[0] == "whisper") {
						this.addWhisperMessageFormatted(message[1], message[2], parseInt(message[3]));
					}
					else {					
						this.addUserMessageFormated(message[0], message[1], message[2], message[3]);
					}
				}
				this.highlightCurrentTab("all");
				break;
			}
			
			case kKeyboardInput.f6:
			{
				//display global chat
				currentChannel = channelType.GLOBAL;
				this.clearChatBox();
				for(var i = 0; i < globalChat.length; i++) {
					var message = globalChat[i] + '';
					message = message.split("§");
					this.addUserMessageFormated(message[0], message[1], message[2], message[3]);
				}
				this.highlightCurrentTab("global");
				break;
			}
			
			case kKeyboardInput.f7:
			{
				//display local chat
				currentChannel = channelType.LOCAL;
				this.clearChatBox();
				for(var i = 0; i < localChat.length; i++) {
					var message = localChat[i] + '';
					message = message.split("§");
					this.addUserMessageFormated(message[0], message[1], message[2], message[3]);
				}
				this.highlightCurrentTab("local");
				break;
			}
			
			case kKeyboardInput.f8:
			{
				//display factions chat
				currentChannel = channelType.FACTION;
				this.clearChatBox();
				for(var i = 0; i < factionChat.length; i++) {
					var message = factionChat[i] + '';
					message = message.split("§");
					this.addUserMessageFormated(message[0], message[1], message[2], message[3]);
				}
				this.highlightCurrentTab("factions");
				break;
			}
			
			case kKeyboardInput.f9:
			{
				//display whisper chat
				currentChannel = channelType.WHISPER;
				this.clearChatBox();
				for(var i = 0; i < whisperChat.length; i++) {
					var message = whisperChat[i] + '';
					message = message.split("§");
					this.addWhisperMessageFormatted(message[1], message[2], parseInt(message[3]));
				}
				this.highlightCurrentTab("whisper");
				break;
			}
			
			case kKeyboardInput.f10:
			{
				//display system chat
				currentChannel = channelType.SYSTEM;
				this.clearChatBox();
				for(var i = 0; i < systemChat.length; i++) {
					var message = systemChat[i] + '';
					message = message.split("§");
					this.addSystemMessageFormatted(message[1], message[2]);
				}
				this.highlightCurrentTab("system");
				break;
			}
        }
    };

	this.highlightCurrentTab = function(channel) {
		for (var chan in channelType) {
			var el = $("#" + channelType[chan] + "Tab");
			el.css("filter", "invert(0%)");
			el.css("-webkit-filter", "invert(0%)");
		}
		var el = $("#" + channel + "Tab");
		el.css("filter", "invert(100%)");
		el.css("-webkit-filter", "invert(100%)");
	};
	
	this.clearChatBox = function() {
	var dead_children = messages[0].children.length;

        if (dead_children > 0) {
            for (var i = 0; i < dead_children; i++) {
                messages.find("div:first").remove();
            }
        }
	};
	
    this.reorder = function () {
        var dead_children = messages[0].children.length - kViewableMessageLimit;

        if (dead_children > 0) {
            for (var i = 0; i < dead_children; i++) {
                messages.find("div:first").remove();
            }
        }

        setTimeout(function () {
            var height = messages[0].scrollHeight;
            messages.scrollTop(height);

            this.dim_then_time();
        }.bind(this), 5);
    };

    this._new_message = function (classType, hasNameTag) {
        var result = { _container: null, content: null, nametag: null };

        var container = document.createElement("div");
        container.setAttribute("class", "mitem " + classType);

        result._container = container;

        if (hasNameTag) {
            var nametag = document.createElement("span");
            nametag.setAttribute("class", "nametag");

            container.appendChild(nametag);
            result.nametag = nametag;
        }

        var message = document.createElement("span");
        container.appendChild(message);

        result.content = message;

        messages.append(container);
        this.reorder();

        return result;
    };

    this.parse_colours = function (text) {

        if (text == null) {
            return kDefaultColour;
        }

        var colours = text.split(',');
        if (colours.length != 3) {
            return kDefaultColour;
        }

        for (var i = 0; i < 3; ++i) {
            colours[i] = Number(colours[i]);
        }

        return "rgba(" + colours[0] + "," + colours[1] + "," + colours[2] + ", 255)";
    };

    //---------------------------------------
    // C++ End point API
    //---------------------------------------
    this.addRawMessage = function (text, colour) {
        if (app.sio_get("Chat", "ShowSystemMessages") == 0) {
            return;
        }

        var colours = this.parse_colours(colour);
        var MessageTag = this._new_message("raw", false);

        MessageTag.content.innerText = text;
        MessageTag.content.style.color = colours;
    };

	// Where ChatBox gets system messages from server
    this.addSystemMessage = function (text, colour) {
        if (app.sio_get("Chat", "ShowSystemMessages") == 0) {
            return;
        }
		
		this.storeMessage("system", null, text, colour);
		
		//check for current channel
		if(currentChannel == "system"|| currentChannel == "all")
			this.addSystemMessageFormatted(text, colour);
	};
	
	// Where system text is outputted to ChatBox
	this.addSystemMessageFormatted = function(text, colour) {
        var MessageClassName = null;
        var MessageColour = null;
        var colours = this.parse_colours(colour);

        if (text.indexOf("---") === 0)
        {
            MessageClassName = "system_sub_head";
            text = text.substr(3);
        }
        else if (text.indexOf("--") === 0)
        {
            MessageClassName = "system_head";
            text = text.substr(2);
        } else if (text.indexOf("~") === 0)
        {
            MessageClassName = "system_console";
            MessageColour = colours;
            text = text.substr(1);
        }
        else
        {
            MessageClassName = "system";
            MessageColour = colours;
        }

        var MessageTag = this._new_message(MessageClassName);

        if (MessageColour)
        {
            MessageTag.content.style.color = MessageColour;
        }

        MessageTag.content.innerText = text;
    };

	// Where ChatBox gets messages from server
    this.addUserMessage = function (channel, name, text, colour) {
        if (app.sio_get("Chat", "ShowPlayerMessages") == 0) {
            return;
        }
		
		this.storeMessage(channel, name, text, colour);
		
		//check for current channel
		if(currentChannel == channel || currentChannel == "all")
			this.addUserMessageFormated(channel, name, text, colour);
	};
	
	
	// Where message text is outputted to ChatBox
	this.addUserMessageFormated = function (channel, name, text, colour) {
        var colours = this.parse_colours(colour);
        var MessageTag = this._new_message("player", true);
        MessageTag.content.innerText = text;

        var tag = null;
        if (channel == "global")
        {
            tag = document.createElement("div");
            tag.setAttribute("class", "nameprefix globaltag");
        }
        else if (channel == "factions")
        {
            tag = document.createElement("div");
            tag.setAttribute("class", "nameprefix factiontag");
        }

        if (tag !== null)
        {
            $(MessageTag.nametag).append(tag);
        }
        
        $(MessageTag.nametag).append( name );
        MessageTag.nametag.style.color = colours;
    };

	// Where ChatBox gets whispers from server
    this.addWhisperMessage = function (name, text, is_local) {
		if (app.sio_get("Chat", "ShowWhisperMessages") == 0) {
            return;
        }
		
		this.storeMessage("whisper", name, text, is_local);
		
		//check for current channel
		if(currentChannel == "whisper" || currentChannel == "all")
			this.addWhisperMessageFormatted(name, text, is_local);
	};
	
	// Where whisper text is outputted to ChatBox
	this.addWhisperMessageFormatted = function (name, text, is_local) {
		// Local messages need a different suffix.
        var MessageTag = this._new_message(is_local ? "whisper-local" : "whisper", true);

        // Setup accordingly.
        MessageTag.content.innerText = text;
        MessageTag.nametag.innerText = name;
    };

    //---------------------------------------
    // Event handlers
    //---------------------------------------
    this.load = function () {
        // Get DOM elements before continuing with messaging initialisation.
        input_box = document.getElementById("message");
        messages = $(document.getElementById("messages"));
        content = $(document.getElementById("content"));
        gm_timer = setInterval(this.check_for_gm.bind(this), 2000);

        // Make the placeholder change when the input_box gains focus.
        input_box.addEventListener('focus', this.on_input_box_focus.bind(this), true);
        input_box.addEventListener('blur', this.on_input_box_unfocus.bind(this), true);
        $(input_box).keydown(this.on_input_box_keypress.bind(this));

        //=================================================
        // Prevent chat de-focus.
        //=================================================
        var g_MouseEvent = false;
        $("input").blur(function () {
            if (g_MouseEvent) {
                $(this).focus();
                g_MouseEvent = false;
            }
        });

        $("body").mousedown(function () {
            g_MouseEvent = false;
        });

        $("#chat").mousedown(function (evt) {
            g_MouseEvent = true;
            evt.stopPropagation();
        });

        // Preference: Chat.Enabled
        if (app.sio_get("Chat", "Enabled") != 0) {
            var anchor = app.sio_get("Chat", "Anchor");
            var pos_x = app.sio_get("Chat", "PositionX");
            var pos_y = app.sio_get("Chat", "PositionY");
            var width = app.sio_get("Chat", "Width");
            var height = app.sio_get("Chat", "Height");

            var anchor_y = anchor.indexOf('t') !== -1 ? "top" : "bottom";
            var anchor_x = anchor.indexOf('r') !== -1 ? "right" : "left";

			//alters chatbox
            var el = $("#chat");
            el.css(anchor_x, pos_x);
            el.css(anchor_y, pos_y);
            el.css("width", width);
            el.css("height", height);
			
			//alters menu bar
			el = $("#menu");
			el.css("width", width);
			
			//alters settings menu
			el = $("#settings");
			el.css("left", width);
			
            $("#chat").show();
			$("#menu").show();
        }

        // Preference: Scaling
        $("body").css("zoom", app.sio_get("WebKit", "SampleScale") * 0.85);

        // Error catching
        window.onerror = (function (msg, url, line, col, error) {
            this.addSystemMessage(msg, "255,0,0");
        }).bind(this);
    };

};